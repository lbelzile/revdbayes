% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predictive.R
\name{pred_gev}
\alias{pred_dgev}
\alias{pred_gev}
\alias{pred_pgev}
\alias{pred_qgev}
\alias{pred_rgev}
\title{GEV-based predictive inference for the largest value observed in N years.}
\usage{
pred_dgev(ev_obj, x, n_years = 100, npy = NULL, log = FALSE)

pred_pgev(ev_obj, q, n_years = 100, npy = NULL, lower_tail = TRUE)

pred_qgev(ev_obj, p, n_years = 100, npy = NULL, lower_tail = TRUE)

pred_rgev(ev_obj, n_years = 100, npy = NULL)
}
\arguments{
\item{ev_obj}{An object of class "evpost", a result of a call to
\code{\link{rpost}} with \code{model = "gev"}, \code{model = "os"}
or \code{model = "pp"}.}

\item{x, q}{Numeric vectors of quantiles.}

\item{n_years}{A numeric vector. Values of N.}

\item{npy}{The mean number of observations per year of data, after
  excluding any missing values, i.e. the number of non-missing observations
  divided by total number of years of non-missing data.

A default value will be assumed if \code{npy} is not supplied:
\itemize{
  \item{\code{model = "gev"}:} \code{npy} = 1, i.e. the data were
    annual maxima.
  \item{\code{model = "os"}:} \code{npy} = 1, i.e. the data were
    annual order statistics.
  \item{\code{model = "pp"}:}
    \code{npy} = \code{length(x$data)} / \code{noy},
    i.e. the value of \code{noy} used in the call to \code{\link{rpost}}
    equated to a block size of one year.
}}

\item{log}{A logical scalar.  If TRUE the log-density is returned.}

\item{lower_tail}{A logical scalar.  If TRUE (default), probabilities
are P[X <= x], otherwise, P[X > x].}

\item{p}{A numeric vector of probabilities in (0,1).}
}
\value{
\itemize{
  \item{\code{pred_dgev:}} A \code{length(x)} by \code{length(n_years)}
  matrix.  Column i contains the predictive density function
  of the \code{n_years[i]} maxiumum evaluated at the values in \code{x}.
  \item{\code{pred_pgev:}} A \code{length(q)} by \code{length(n_years)}
  matrix.  Column i contains the predictive distribution function
  of the \code{n_years[i]} maxiumum evaluated at the values in \code{q}.
  \item{\code{pred_qgev:}} A \code{length(p)} by \code{length(n_years)}
  matrix.  Column i contains the predictive quantiles of the
  \code{n_years[i]} maxiumum evaluated at the probabilities in \code{p} .
  \item{\code{pred_rgev:}} An \code{nrow(ev_obj$sim_vals)} by
  \code{length(n_years)} matrix.  Column i contains
  \code{nrow(ev_obj$sim_vals)} vaues simulated from the predictive
  distribution of the \code{n_years[i]} maxiumum.
}
}
\description{
Density function, distribution function, quantile function and
random generation for the largest value observed in N years using
Bayesian predictive inference based on a generalized extreme value (GEV)
distribution.
}
\details{
In each function we first infer the number, mult, of blocks in
  n_years years, and then convert the posterior simulated GEV
  parameters to the \code{n_years} level of aggregation.

  In \code{pred_dgev} we calculate using \code{\link{dgev}}
  the GEV density at \code{x} for each of the posterior samples
  of the location, scale and shape parameters.  Then we take the
  mean of these values.

  In \code{pred_pgev} we calculate using \code{\link{pgev}}
  the GEV density at \code{q} for each of the posterior samples
  of the location, scale and shape parameters.  Then we take the
  mean of these values.

  In \code{pred_qgev} we first calculate initial estimates of the
  required predictive quantiles: we calculate using \code{\link{qgev}}
  the GEV density at \code{p} for each of the posterior samples
  of the location, scale and shape parameters.  Then we take the
  mean of these values.  Then we solve \code{pred_pgev}(q) = \code{p[i]}
  numerically for q for each element \code{p[i]} of \code{p}.

  In \code{pred_rgev} for each simulated value of the GEV parameters
  at the \code{n_years} we simulate one value from this GEV distribution
  using \code{\link{rgev}}.  Thus, each sample from the predictive
  distribution is of a size equal to the size of the posterior sample.
}
\examples{
data(portpirie)
mat <- diag(c(10000, 10000, 100))
pn <- set_prior(prior = "norm", model = "gev", mean = c(0,0,0), cov = mat)
gevp  <- rpost(n = 1000, model = "gev", prior = pn, data = portpirie)

pred_dgev(gevp, q)
pred_dgev(gevp, q, n_years <- c(100, 1000))

q <- seq(4, 7, 0.1)
pred_pgev(gevp, q)
pred_pgev(gevp, q, n_years <- c(100, 1000))

p <- c(0.025, 0.25, 0.5, 0.75, 0.975)
qq <- pred_qgev(gevp, p)
pred_pgev(gevp, qq)
pred_qgev(gevp, p, n_years <- c(100, 1000))

sim100 <- pred_rgev(gevp)
sim2 <- pred_rgev(gevp, n_years <- c(100, 1000))
}

