// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/revdbayes.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// loggp
double loggp(const Rcpp::NumericVector& x, const Rcpp::List& ss);
static SEXP revdbayes_loggp_try(SEXP xSEXP, SEXP ssSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List& >::type ss(ssSEXP);
    rcpp_result_gen = Rcpp::wrap(loggp(x, ss));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP revdbayes_loggp(SEXP xSEXP, SEXP ssSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(revdbayes_loggp_try(xSEXP, ssSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// loglik_xptr
SEXP loglik_xptr(std::string fstr);
static SEXP revdbayes_loglik_xptr_try(SEXP fstrSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type fstr(fstrSEXP);
    rcpp_result_gen = Rcpp::wrap(loglik_xptr(fstr));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP revdbayes_loglik_xptr(SEXP fstrSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(revdbayes_loglik_xptr_try(fstrSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// gp_phi_to_theta
Rcpp::NumericVector gp_phi_to_theta(const Rcpp::NumericVector& phi, const Rcpp::List& user_args);
static SEXP revdbayes_gp_phi_to_theta_try(SEXP phiSEXP, SEXP user_argsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type phi(phiSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List& >::type user_args(user_argsSEXP);
    rcpp_result_gen = Rcpp::wrap(gp_phi_to_theta(phi, user_args));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP revdbayes_gp_phi_to_theta(SEXP phiSEXP, SEXP user_argsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(revdbayes_gp_phi_to_theta_try(phiSEXP, user_argsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// phi_to_theta_xptr
SEXP phi_to_theta_xptr(std::string fstr);
static SEXP revdbayes_phi_to_theta_xptr_try(SEXP fstrSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type fstr(fstrSEXP);
    rcpp_result_gen = Rcpp::wrap(phi_to_theta_xptr(fstr));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP revdbayes_phi_to_theta_xptr(SEXP fstrSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(revdbayes_phi_to_theta_xptr_try(fstrSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// gp_mdi
double gp_mdi(const Rcpp::NumericVector& x, const Rcpp::List& pars);
static SEXP revdbayes_gp_mdi_try(SEXP xSEXP, SEXP parsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type x(xSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List& >::type pars(parsSEXP);
    rcpp_result_gen = Rcpp::wrap(gp_mdi(x, pars));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP revdbayes_gp_mdi(SEXP xSEXP, SEXP parsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(revdbayes_gp_mdi_try(xSEXP, parsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int revdbayes_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("double(*loggp)(const Rcpp::NumericVector&,const Rcpp::List&)");
        signatures.insert("SEXP(*loglik_xptr)(std::string)");
        signatures.insert("Rcpp::NumericVector(*gp_phi_to_theta)(const Rcpp::NumericVector&,const Rcpp::List&)");
        signatures.insert("SEXP(*phi_to_theta_xptr)(std::string)");
        signatures.insert("double(*gp_mdi)(const Rcpp::NumericVector&,const Rcpp::List&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP revdbayes_RcppExport_registerCCallable() { 
    R_RegisterCCallable("revdbayes", "revdbayes_loggp", (DL_FUNC)revdbayes_loggp_try);
    R_RegisterCCallable("revdbayes", "revdbayes_loglik_xptr", (DL_FUNC)revdbayes_loglik_xptr_try);
    R_RegisterCCallable("revdbayes", "revdbayes_gp_phi_to_theta", (DL_FUNC)revdbayes_gp_phi_to_theta_try);
    R_RegisterCCallable("revdbayes", "revdbayes_phi_to_theta_xptr", (DL_FUNC)revdbayes_phi_to_theta_xptr_try);
    R_RegisterCCallable("revdbayes", "revdbayes_gp_mdi", (DL_FUNC)revdbayes_gp_mdi_try);
    R_RegisterCCallable("revdbayes", "revdbayes_RcppExport_validate", (DL_FUNC)revdbayes_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"revdbayes_loggp", (DL_FUNC) &revdbayes_loggp, 2},
    {"revdbayes_loglik_xptr", (DL_FUNC) &revdbayes_loglik_xptr, 1},
    {"revdbayes_gp_phi_to_theta", (DL_FUNC) &revdbayes_gp_phi_to_theta, 2},
    {"revdbayes_phi_to_theta_xptr", (DL_FUNC) &revdbayes_phi_to_theta_xptr, 1},
    {"revdbayes_gp_mdi", (DL_FUNC) &revdbayes_gp_mdi, 2},
    {"revdbayes_RcppExport_registerCCallable", (DL_FUNC) &revdbayes_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_revdbayes(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
